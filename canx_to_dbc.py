#!/usr/bin/env python3
import xml.etree.ElementTree as ET
import argparse
import os

def canx_to_dbc(input_file, output_file):
    tree = ET.parse(input_file)
    root = tree.getroot()

    dbc_lines = []
    dbc_lines.append('VERSION "Generated by canx2dbc"\n')
    dbc_lines.append("NS_ :\n")
    dbc_lines.append("BS_:\n")
    dbc_lines.append("BU_:\n")

    for mob in root.findall("mob"):
        msg_name = mob.attrib.get("id")

        # Base ID is hex in .canx (e.g. "640" means 0x640)
        cid = mob.attrib.get("canbusID")
        base_id = int(cid, 16)

        dlc = int(mob.attrib.get("width"))

        # Each frame -> one BO_ message with ID = base_id + offset
        for frame in mob.findall("frame"):
            frame_offset = int(frame.attrib.get("offset", "0"))
            real_id = base_id + frame_offset   # integer (we'll print decimal)
            frame_name = f"{msg_name}_f{frame_offset}"

            dbc_lines.append(f"\nBO_ {real_id} {frame_name}: {dlc} Vector__XXX")

            for ch in frame.findall("channel"):
                sig_name = ch.attrib.get("id")
                byte_offset = int(ch.attrib.get("byteOffset", "0"))
                unit = ch.attrib.get("unit", "")
                type_info = ch.attrib.get("type", "u8")

                # endian + signed
                is_big_endian = "-be" in type_info or type_info.startswith("s") and "-be" in type_info
                is_signed = type_info.startswith("s")
                endian_flag = 0 if is_big_endian else 1  # DBC: 0=big (Motorola), 1=little (Intel)

                # bit length
                if "64" in type_info:
                    bit_size = 64
                elif "32" in type_info:
                    bit_size = 32
                elif "16" in type_info:
                    bit_size = 16
                else:
                    bit_size = 8

                # START BIT calculation:
                # - Little-endian (Intel): start = byte_offset*8  (LSB-first)
                # - Big-endian (Motorola): start = byte_offset*8 + 7  (MSB of that byte)
                if is_big_endian:
                    bit_start = byte_offset * 8 + 7
                else:
                    bit_start = byte_offset * 8

                dbc_lines.append(
                    f" SG_ {sig_name} : {bit_start}|{bit_size}@{endian_flag}{'-' if is_signed else '+'} "
                    f"(1,0) [0|0] \"{unit}\" Vector__XXX"
                )

    with open(output_file, "w", encoding="utf-8") as f:
        f.write("\n".join(dbc_lines))

    print(f"[OK] DBC generated: {output_file}")


def main():
    parser = argparse.ArgumentParser(description="Convert Ecumaster .canx to .dbc")
    parser.add_argument("input", help="Input .canx file")
    parser.add_argument("output", help="Output .dbc file")
    args = parser.parse_args()

    if not os.path.exists(args.input):
        print(f"Error: file '{args.input}' not found.")
        return

    canx_to_dbc(args.input, args.output)


if __name__ == "__main__":
    main()
